<?xml version="1.0"?>
<ps_doc title="Grape API calls" titlepage="no">
<h1 id="grape_api_calls">API Calls</h1>

<h2>Registering API calls</h2>
<p>
API calls are defined in json files that looks like this:
	<code>{
	"description": "Calculate the square root of a number",
	"id": "/maths/sqrt", 
	"name": "SquareRoot",
	"sqlfunc": "maths_sqrt",
	"type": "object",
	"properties": {
		"value": { "type": "number", "description": "The input value for the square root function" }
	},
	"result": {
		"type": "object",
		"properties": {
			"result": {"type": "number", "description": "The resulting number"},
			"status": {"enum": ["ERROR", "OK"]}
		}
	}
}</code>

Usually, each API call lives in it's own file.  However, it is possible to have an array with multiple API call definitions inside a JSON file.
</p>
<p>

	These files live in multiple directories. The list of directories it is found in, is defined in the configuration option "<b><i>api_directories</i></b>". This option is usually defined in the configuration files read by Grape upon startup. Each grape module will usually have it's own directory to add to the list. After Grape Express App Instances have been created, each of the directories found in this option is traversed, and all JSON files read and parsed.
</p>

<h2>Format of JSON Schema API call</h2>
<p>
The JSON format used to define APIs are loosely based on JSON Schema standard (<a href="http://json-schema.org">http://json-schema.org</a>).
The fields in a schema object:
<code>
{
	<blue>"description"</blue>: <r>"API call description"</r>,
	<blue>"id"</blue>: <r>"URL of the call"</r>,
	<blue>"name"</blue>: <r>"CamelCase name for this call"</r>,
	<blue>"sqlfunc"</blue>: <r>"SQL function"</r>,
	<blue>"sqlfunctype"</blue>: <r>"Specify jsonb here for JSONB functions. Defaults to JSON"</r>,
	<blue>"jsfile": <r>"JavaScript file to execute"</r></blue>
	<blue>"type"</blue>: <r>"Body type - use 'object' for POST methods and 'query' for GET"</r>,
	<blue>"method"</blue>: <r>"GET or POST - defaults to POST"</r>,
	<blue>"roles"</blue>: <r>"An array of role names that is allowed to execute this request"</r>,
	<blue>"properties"</blue>: <r>{ Set of properties in this body. Used for POST requests }</r>,
	<blue>"validation_string"</blue>: <r>"Validation string. Use this to validate GET/POST input"</r>,
	<blue>"no_validation"</blue>: <r>true or false. If this is true, validation will be disabled for this call (default to false)</r>,
	<blue>"return"</blue>: <r>{ 
			<blue>"type"</blue>: <r>"Return type (default to object)"</r>
			<blue>"properties"</blue>: <r>{ Set of properties in this body }</r>
			<blue>"example"</blue>: <r>{ Example of a resulting JSON }</r>
		}</r>
}
</code>
The <blue>properties</blue> field, which is used with the "object" type, is an associative array with the field name as key, and the field properties as the object.  For example:
<code>"<b>properties</b>": {
	"<b>number_field</b>": {"<b>type</b>": "<green>number</green>", "<b>description</b>": "Number field 1"},
	"<b>string_field</b>": {"<b>type</b>": "<green>string</green>", "<b>description</b>": "A strings field"},
		"<b>array_field</b>": {"<b>type</b>": "<green>array</green>", "<b>items</b>": { 
		"<b>type</b>": "<green>string</green>" 
		}, 
		"<b>description</b>": "List of strings"
	}
}
</code>


<h2>API Handlers</h2>
<p>
	Grape relays the API request to a handler. This handler can either be a function in the database, or a JavaScript file (TODO: write handlers in any language).
</p>

<h3>Database Handlers</h3>
<p>
	Database API calls are the most commonly used API calls. The handlers are written as functions/stored procedures in the database. The functions accepts and returns a JSON(B) object. The object is created from the request's body (in case of POST), or the request's query parameters (in the case of GETs). The name of the function is specified in the "<b><i>sqlfunc</i></b>" field. If the function accepts JSONB (instead of JSON), the value of the field "<b><i>sqlfunctype</i></b>" should be set to "jsonb".
<img src="db_api_call.png" title="Anatomy of a DB API" width="3cm" />

The logic of the function needs to be implemented in PostgreSQL. For example, a function calculating the square root of a number:
<code lang="sql">
	/**
	 * @api_usage MathsSqrt
	 * @api_url POST /maths/sqrt
	 */
	CREATE OR REPLACE FUNCTION maths_sqrt (JSON) RETURNS JSON AS $$
	DECLARE
		_value NUMERIC;
		_result NUMERIC;
	BEGIN

		_value := ($1->>'value')::NUMERIC; <r>-- Extract values from JSON</r>

		_result := sqrt(_value);           <r>-- Calculation</r>

		RETURN grape.api_success('result', _result); <r>-- Build and return JSON object</r>
	END; $$ LANGUAGE plpgsql;
</code>
</p>

<h3>JavaScript Handlers</h3>
<p>
	The API handler is implemented as a JavaScript function, and handled completely in the Node.JS environment. The file should be specified using the "<b><i>js_file</i></b>" field in the JSON schema.
</p>
<p>
	The JavaScript file should return a function, for example:
<code>module.exports = function() {
	return function(req, res) {
		// API CODE GOES HERE
		res.end();
	}
}</code>
</p>

</p>

<p>
	An example of a schema definition for the sqrt function:

<h4>Validation</h4>
Validation happen against the value of the <i>validate</i> field. This field contains a string, in the following format:
<code>
Validate string syntax:
      begin_expr ::= "(" <![CDATA[<begin_expr>]]> "," <![CDATA[<param-def>]]> ")"
      param-def ::= <![CDATA[<param-name>]]> ":" <![CDATA[<data-type>]]> <![CDATA[<modifier-list>]]>
      modifier-list ::= <![CDATA[<opt-modifier>]]> <![CDATA[<modifier-list>]]>
      opt-modifier ::= "*" | "E" | "0" | ""
      data-type ::= "s" | "i" | "f" | "b" | "d" | "t" | "a"

Data types:
      s text
      i integer
      f float
      b boolean
      d date
      t date

Modifiers:
      * optional is true (default = false)
      E Empty becomes null
      0 Nullable

Examples:
      (batch_labreport_id: i, product_id: i, labreport)
</code>

<note color="green">More examples are available in the grape repository, in the <b>examples/</b> subdirectory </note>

</p>

<h4>Generating documentation</h4>
In the Viticulture repository, a script called <i>scripts/build_schema_api_docs.js</i> can be used to generate VXML documentation from the API JSON files.
<code>  Usage: build_schema_api_docs [options] directory|file [directory|file directory|file ...]

  Options:

    -h, --help                  output usage information
    -o, --output [output_file]  Output file (vxml)</code>


<h2 id="grape-access-control">Access control on API calls</h2>
<p>
	When an HTTP request is received, Grape attempts to connect a valid session to the request. This is done by looking for an <i>X-SessionID</i> header, and additionally looking for a session ID cookie. If a valid session could be identified, the user's access roles are loaded. If no session exists, the role "guest" is used.
</p>
<p>
	Each user has a list of roles assigned to him/her, and each API call has a list of access roles that is allowed to call it. There has to be an overlap between these two set of access roles, otherwise the request is denied.  See <link id="sec-grape-auth">Authentication</link> for more information.
</p>
<p>
	The list of allowed access roles for each API call is defined in the "<i>roles</i>" field in the JSON schema. All users belongs to one or more roles, and always to the role named <b>all</b>. 

API calls are registered in the database (table <tname>access_path</tname>) by <b>path</b>, <b>method</b> and the <b>role</b> allowed.  The <b>path</b> is a regular expression, matching the incoming URL of the request.
<note color="green">The SQL function <icode>grape.add_access_path (_path TEXT, _roles TEXT[], _methods TEXT[])</icode> can be used to add a new access path. For initial data, this is kept in the project's <fname>db/data/access_paths.sql</fname></note>
</p>


<h2>Consuming an API call</h2>
<p>
	The API (<link id="grape-builtin-api-calls">built-in API calls</link> and the application's API calls) is available over HTTP/HTTPS on the same port as the frontend. Client-side software can connect to this URL, and can be written in any technology/environment. See <link id="grape-access-control">access control</link> for details regarding the HTTP header <i>X-SessionID</i>.
</p>
<p>
In order to use an API call, you will need to know the following:
	<ol>
		<li>The URL of the call. This will look like a typical path, for example "/login"</li>
		<li>The call method. This will usually be <b>GET</b> or <b>POST</b></li>
		<li>The input parameters. If the call's method is POST, this will be a JSON object containing fields. If it is GET, the input parameters are found in the URL</li>
	</ol>
	The API is consumed by making a HTTP request to the API's URL with the appropriate input parameters or body. Usually, session information will be sent in the HTTP headers in the <i>X-SessionID</i> header. 
</p>
<h3>Using HTTP Authorization</h3>
By default, grape applications support HTTP Authentication (Basic). When using this authentication method, it is not necessary to make a separate call to <i>/grape/login</i>. The username and password can be included in the HTTP headers. This should only be used over TLS, as the credentials can be reverse-encoded. The "Basic" HTTP authentication scheme is defined in <a href="https://tools.ietf.org/html/rfc7617">RFC 7617</a>, which transmits credentials as user ID/password pairs, encoded using base64.
</ps_doc>

